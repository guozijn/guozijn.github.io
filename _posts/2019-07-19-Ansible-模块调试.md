## 调试（本地）
在 localhost 中进入模块并使用pdb进行调试：

- 在模块中设置断点： import pdb; pdb.set_trace()
- 在本地计算机上运行该模块： $ python -m pdb ./my_new_test_module.py ./args.json

## 调试（远程）
要调试在远程目标上运行的模块（非localhost）：

1. 在您的控制节点（运行Ansible）上设置环境变量 **ANSIBLE_KEEP_REMOTE_FILES=1** 告诉Ansible保留它发送到远程计算机的模块，而不是在Playbook运行后删除它们。
2. 指定-vvv（详细，3个v以上即可显示）以显示Ansible正在用于模块的远程位置（以及许多其他内容）。
3. 记下用于在远程主机上存储模块的ansible目录。此目录通位于常ansible_user的主目录下~/.ansible/tmp/ansible-tmp-...。
4. 在playbook运行后SSH进入远程节点。
5. 进入到您在步骤3中记下的目录。
6. 从Ansible发送到远程主机的压缩文件中提取要调试的模块：$python AnsiballZ_my_test_module.py explode。Ansible会将模块展开为一个./debug-dir目录。 您可以选择通过指定python AnsiballZ_my_test_module.py来运行压缩文件。

7. 导航到调试目录：
```bash
$ cd debug-dir
```

1. 修改或设置断点__main__.py。
1. 确保解压缩的模块是可执行的：
```bash
$ chmod 755 __main__.py
```

1. 直接运行解压缩的模块，传递args包含最初传递的参数的文件：这种方法适用于再现行为以及修改调试参数。
```bash
$ ./__main__.py args
```

## 示例

此处不区分本地或远程节点，以ansible内置模块进行示例。

- 运行ansible命令

```bash
ANSIBLE_KEEP_REMOTE_FILES=1 ansible localhost -m setup -vvv
```

![run ansible cmd](/assets/images/run-ansible-cmd.png)

- 进入ansible tmp目录

```bash
cd /root/.ansible/tmp/ansible-tmp-1564381025.55-236313195829600/
```

![enter ansible tmp dir](/assets/images/enter-ansible-tmp-dir.png)

- 查看模块文件

```bash
vim setup.py
```

```python
#!/usr/bin/python2
# -*- coding: utf-8 -*-
ANSIBALLZ_WRAPPER = True # For test-module script to tell this is a ANSIBALLZ_WRAPPER
# This code is part of Ansible, but is an independent component.
# The code in this particular templatable string, and this templatable string
# only, is BSD licensed.  Modules which end up using this snippet, which is
# dynamically combined together by Ansible still belong to the author of the
# module, and they may assign their own license to the complete work.
#
# Copyright (c), James Cammarata, 2016
# Copyright (c), Toshio Kuratomi, 2016
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
import os
import os.path
import sys
import __main__

# For some distros and python versions we pick up this script in the temporary
# directory.  This leads to problems when the ansible module masks a python
# library that another import needs.  We have not figured out what about the
# specific distros and python versions causes this to behave differently.
#
# Tested distros:
# Fedora23 with python3.4  Works
# Ubuntu15.10 with python2.7  Works
# Ubuntu15.10 with python3.4  Fails without this
# Ubuntu16.04.1 with python3.5  Fails without this
# To test on another platform:
# * use the copy module (since this shadows the stdlib copy module)
# * Turn off pipelining
# * Make sure that the destination file does not exist
# * ansible ubuntu16-test -m copy -a 'src=/etc/motd dest=/var/tmp/m'
# This will traceback in shutil.  Looking at the complete traceback will show
# that shutil is importing copy which finds the ansible module instead of the
# stdlib module
scriptdir = None
try:
    scriptdir = os.path.dirname(os.path.realpath(__main__.__file__))
except (AttributeError, OSError):
    # Some platforms don't set __file__ when reading from stdin
    # OSX raises OSError if using abspath() in a directory we don't have
    # permission to read (realpath calls abspath)
    pass
if scriptdir is not None:
    sys.path = [p for p in sys.path if p != scriptdir]

import base64
import shutil
import zipfile
import tempfile
import subprocess

if sys.version_info < (3,):
    bytes = str
    PY3 = False
else:
    unicode = str
    PY3 = True
try:
    # Python-2.6+
    from io import BytesIO as IOStream
except ImportError:
    # Python < 2.6
    from StringIO import StringIO as IOStream

ZIPDATA = """UEsDBBQAAAAIACJy/U6yxdenYQAAAHcAAAATAAAA..."""
# 太长，此处省略。

def invoke_module(module, modlib_path, json_params):
    pythonpath = os.environ.get('PYTHONPATH')
    if pythonpath:
        os.environ['PYTHONPATH'] = ':'.join((modlib_path, pythonpath))
    else:
        os.environ['PYTHONPATH'] = modlib_path

    p = subprocess.Popen(['/usr/bin/python2', module], env=os.environ, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
    (stdout, stderr) = p.communicate(json_params)

    if not isinstance(stderr, (bytes, unicode)):
        stderr = stderr.read()
    if not isinstance(stdout, (bytes, unicode)):
        stdout = stdout.read()
    if PY3:
        sys.stderr.buffer.write(stderr)
        sys.stdout.buffer.write(stdout)
    else:
        sys.stderr.write(stderr)
        sys.stdout.write(stdout)
    return p.returncode

def debug(command, zipped_mod, json_params):
    # The code here normally doesn't run.  It's only used for debugging on the
    # remote machine.
    #
    # The subcommands in this function make it easier to debug ansiballz
    # modules.  Here's the basic steps:
    #
    # Run ansible with the environment variable: ANSIBLE_KEEP_REMOTE_FILES=1 and -vvv
    # to save the module file remotely::
    #   $ ANSIBLE_KEEP_REMOTE_FILES=1 ansible host1 -m ping -a 'data=october' -vvv
    #
    # Part of the verbose output will tell you where on the remote machine the
    # module was written to::
    #   [...]
    #   <host1> SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o
    #   PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o
    #   ControlPath=/home/badger/.ansible/cp/ansible-ssh-%h-%p-%r -tt rhel7 '/bin/sh -c '"'"'LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
    #   LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping'"'"''
    #   [...]
    #
    # Login to the remote machine and run the module file via from the previous
    # step with the explode subcommand to extract the module payload into
    # source files::
    #   $ ssh host1
    #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping explode
    #   Module expanded into:
    #   /home/badger/.ansible/tmp/ansible-tmp-1461173408.08-279692652635227/ansible
    #
    # You can now edit the source files to instrument the code or experiment with
    # different parameter values.  When you're ready to run the code you've modified
    # (instead of the code from the actual zipped module), use the execute subcommand like this::
    #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping execute

    # Okay to use __file__ here because we're running from a kept file
    basedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'debug_dir')
    args_path = os.path.join(basedir, 'args')
    script_path = os.path.join(basedir, 'ansible_module_setup.py')

    if command == 'explode':
        # transform the ZIPDATA into an exploded directory of code and then
        # print the path to the code.  This is an easy way for people to look
        # at the code on the remote machine for debugging it in that
        # environment
        z = zipfile.ZipFile(zipped_mod)
        for filename in z.namelist():
            if filename.startswith('/'):
                raise Exception('Something wrong with this module zip file: should not contain absolute paths')

            dest_filename = os.path.join(basedir, filename)
            if dest_filename.endswith(os.path.sep) and not os.path.exists(dest_filename):
                os.makedirs(dest_filename)
            else:
                directory = os.path.dirname(dest_filename)
                if not os.path.exists(directory):
                    os.makedirs(directory)
                f = open(dest_filename, 'wb')
                f.write(z.read(filename))
                f.close()

        # write the args file
        f = open(args_path, 'wb')
        f.write(json_params)
        f.close()

        print('Module expanded into:')
        print('%s' % basedir)
        exitcode = 0

    elif command == 'execute':
        # Execute the exploded code instead of executing the module from the
        # embedded ZIPDATA.  This allows people to easily run their modified
        # code on the remote machine to see how changes will affect it.
        # This differs slightly from default Ansible execution of Python modules
        # as it passes the arguments to the module via a file instead of stdin.

        # Set pythonpath to the debug dir
        pythonpath = os.environ.get('PYTHONPATH')
        if pythonpath:
            os.environ['PYTHONPATH'] = ':'.join((basedir, pythonpath))
        else:
            os.environ['PYTHONPATH'] = basedir

        p = subprocess.Popen(['/usr/bin/python2', script_path, args_path],
                env=os.environ, shell=False, stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, stdin=subprocess.PIPE)
        (stdout, stderr) = p.communicate()

        if not isinstance(stderr, (bytes, unicode)):
            stderr = stderr.read()
        if not isinstance(stdout, (bytes, unicode)):
            stdout = stdout.read()
        if PY3:
            sys.stderr.buffer.write(stderr)
            sys.stdout.buffer.write(stdout)
        else:
            sys.stderr.write(stderr)
            sys.stdout.write(stdout)
        return p.returncode

    elif command == 'excommunicate':
        # This attempts to run the module in-process (by importing a main
        # function and then calling it).  It is not the way ansible generally
        # invokes the module so it won't work in every case.  It is here to
        # aid certain debuggers which work better when the code doesn't change
        # from one process to another but there may be problems that occur
        # when using this that are only artifacts of how we're invoking here,
        # not actual bugs (as they don't affect the real way that we invoke
        # ansible modules)

        # stub the args and python path
        sys.argv = ['setup', args_path]
        sys.path.insert(0, basedir)

        from ansible_module_setup import main
        main()
        print('WARNING: Module returned to wrapper instead of exiting')
        sys.exit(1)
    else:
        print('WARNING: Unknown debug command.  Doing nothing.')
        exitcode = 0

    return exitcode

if __name__ == '__main__':
    #
    # See comments in the debug() method for information on debugging
    #

    ANSIBALLZ_PARAMS = '{"ANSIBLE_MODULE_ARGS": {"_ansible_version": "2.6.5", "_ansible_selinux_special_fs": ["fuse", "nfs", "vboxsf", "ramfs", "9p"], "_ansible_no_log": false, "_ansible_module_name": "setup", "_ansible_remote_tmp": "~/.ansible/tmp", "_ansible_verbosity": 3, "_ansible_keep_remote_files": true, "_ansible_syslog_facility": "LOG_USER", "_ansible_socket": null, "_ansible_diff": false, "_ansible_debug": false, "_ansible_shell_executable": "/bin/sh", "_ansible_check_mode": false, "_ansible_tmpdir": "/root/.ansible/tmp/ansible-tmp-1564381025.55-236313195829600/"}}'
    if PY3:
        ANSIBALLZ_PARAMS = ANSIBALLZ_PARAMS.encode('utf-8')
    try:
        # There's a race condition with the controller removing the
        # remote_tmpdir and this module executing under async.  So we cannot
        # store this in remote_tmpdir (use system tempdir instead)
        temp_path = tempfile.mkdtemp(prefix='ansible_')

        zipped_mod = os.path.join(temp_path, 'ansible_modlib.zip')
        modlib = open(zipped_mod, 'wb')
        modlib.write(base64.b64decode(ZIPDATA))
        modlib.close()

        if len(sys.argv) == 2:
            exitcode = debug(sys.argv[1], zipped_mod, ANSIBALLZ_PARAMS)
        else:
            z = zipfile.ZipFile(zipped_mod, mode='r')
            module = os.path.join(temp_path, 'ansible_module_setup.py')
            f = open(module, 'wb')
            f.write(z.read('ansible_module_setup.py'))
            f.close()

            # When installed via setuptools (including python setup.py install),
            # ansible may be installed with an easy-install.pth file.  That file
            # may load the system-wide install of ansible rather than the one in
            # the module.  sitecustomize is the only way to override that setting.
            z = zipfile.ZipFile(zipped_mod, mode='a')

            # py3: zipped_mod will be text, py2: it's bytes.  Need bytes at the end
            sitecustomize = u'import sys\nsys.path.insert(0,"%s")\n' %  zipped_mod
            sitecustomize = sitecustomize.encode('utf-8')
            # Use a ZipInfo to work around zipfile limitation on hosts with
            # clocks set to a pre-1980 year (for instance, Raspberry Pi)
            zinfo = zipfile.ZipInfo()
            zinfo.filename = 'sitecustomize.py'
            zinfo.date_time = ( 2019, 7, 29, 6, 17, 5)
            z.writestr(zinfo, sitecustomize)
            z.close()

            exitcode = invoke_module(module, zipped_mod, ANSIBALLZ_PARAMS)
    finally:
        try:
            shutil.rmtree(temp_path)
        except (NameError, OSError):
            # tempdir creation probably failed
            pass
    sys.exit(exitcode)

```

从这里来看，大概能描述ansible的工作原理。ansible将模块依赖的内置ansible库打包成zip格式的压缩文件，并且使用base64进行编码，放在一个python脚本中，发送到远程节点上，执行完之后，将执行结果发送的执行ansible命令的master节点上，最后将结果经过处理之后打印到屏幕输出。

- 展开模块，查看目录结构

```
python setup.py explode
ls debug_dir
tree -d
```

![explode ansible module](/assets/images/explode-ansible-module.png)

可以看到，通过explode命令可以将ansible模块的内容提取到debug_dir目录，在debug_dir中，有一个目录，两个文件。

- ansible # 这个模块依赖的ansible library
- ansible_module_setup.py # 调用模块的脚本
- args # 运行模块的参数

在ansible 2.8以前，存在一个bug(https://github.com/ansible/ansible/issues/49473)，只能获取到第一个ipv6地址，2.8以后的版本已经修复。在2.8以前的版本，我们可以临时去修改ansible library中对应的逻辑，使它能够完整地获取到所有的ipv6地址。

```bash
vim debug_dir/ansible/module_utils/facts/network/linux.py
```

```python
                    elif words[0] == 'inet6':
                        if 'peer' == words[2]:
                            address = words[1]
                            _, prefix = words[3].split('/')
                            scope = words[5]
                        else:
                            address, prefix = words[1].split('/')
                            scope = words[3]
                        if 'ipv6' not in interfaces[device]:
                        # 这个地方在过滤完节点网络设备上的第一个ipv6地址时，
                        # 会在interfaces这个dict下面对应的设备下添加一个
                        # ipv6的list，用于记录ipv6地址信息。当第一个地址
                        # 添加上之后，就不会再次命中这个条件，所以，后面的
                        # 地址也就不会添加到 ansible facts 中了。
                            interfaces[device]['ipv6'] = []
                            interfaces[device]['ipv6'].append({
                                'address': address,
                                'prefix': prefix,
                                'scope': scope
                            })
```

- 修改diff：

```diff
                    elif words[0] == 'inet6':
                        if 'peer' == words[2]:
                            address = words[1]
                            _, prefix = words[3].split('/')
                            scope = words[5]
                        else:
                            address, prefix = words[1].split('/')
                            scope = words[3]
                        if 'ipv6' not in interfaces[device]:
                            interfaces[device]['ipv6'] = []
                            interfaces[device]['ipv6'] = []
-                           interfaces[device]['ipv6'].append({
-                               'address': address,
-                               'prefix': prefix,
-                               'scope': scope
-                           })
+                       interfaces[device]['ipv6'].append({
+                           'address': address,
+                           'prefix': prefix,
+                           'scope': scope
+                        })
```

这个append操作不应该放在这个条件下，移出这个缩进块。

- 本地执行脚本验证

我们可以直接在debug_dir中执行脚本进行调试或验证结果。

1. 修改前
```bash
cd debug_dir
python ansible_module_setup.py args | jq .ansible_facts.ansible_em3.ipv6
[
  {
    "scope": "site",
    "prefix": "64",
    "address": "fec0:0:1a:1::d"
  }
]
```

![ansible facts network linux 01](/assets/images/facts_network_linux_01.png)

2. 修改后
```bash
python ansible_module_setup.py args | jq .ansible_facts.ansible_em3.ipv6
[
  {
    "scope": "site",
    "prefix": "64",
    "address": "fec0:0:1a:1::d"
  },
  {
    "scope": "site",
    "prefix": "64",
    "address": "fec0:0:1a:1::c"
  },
  {
    "scope": "link",
    "prefix": "64",
    "address": "fe80::eef4:bbff:fed9:83d4"
  }
]
```
![ansible facts network linux 02](/assets/images/facts_network_linux_02.png)
