## 调试（本地）
在 localhost 中进入模块并使用pdb进行调试：

- 在模块中设置断点： import pdb; pdb.set_trace()
- 在本地计算机上运行该模块： $ python -m pdb ./my_new_test_module.py ./args.json

## 调试（远程）
要调试在远程目标上运行的模块（非localhost）：

1. 在您的控制节点（运行Ansible）上设置环境变量 **ANSIBLE_KEEP_REMOTE_FILES=1** 告诉Ansible保留它发送到远程计算机的模块，而不是在Playbook运行后删除它们。
2. 指定-vvv（详细，3个v以上即可显示）以显示Ansible正在用于模块的远程位置（以及许多其他内容）。
3. 记下用于在远程主机上存储模块的ansible目录。此目录通位于常ansible_user的主目录下~/.ansible/tmp/ansible-tmp-...。
4. 在playbook运行后SSH进入远程节点。
5. 进入到您在步骤3中记下的目录。
6. 提取要调试的模块：$python AnsiballZ_my_test_module.py explode。这个命令会将模块展开为一个./debug-dir目录。可通过命令 python AnsiballZ_my_test_module.py 直接运行压缩文件。

7. 导航到调试目录：
```bash
$ cd debug-dir
```

1. 修改或设置断点__main__.py。
1. 确保解压缩的模块是可执行的：
```bash
$ chmod 755 __main__.py
```

1. 直接运行解压缩的模块，传递args包含最初传递的参数的文件：这种方法适用于再现行为以及修改调试参数。
```bash
$ ./__main__.py args
```

## 示例

此处不区分本地或远程节点，以ansible内置模块进行示例。

- 运行ansible命令

```bash
ANSIBLE_KEEP_REMOTE_FILES=1 ansible localhost -m setup -vvv
```

![run ansible cmd](/assets/images/run-ansible-cmd.png)

- 进入ansible tmp目录

```bash
cd /root/.ansible/tmp/ansible-tmp-1564381025.55-236313195829600/
```

![enter ansible tmp dir](/assets/images/enter-ansible-tmp-dir.png)

- 查看setup.py

<details>
  <summary>setup.py</summary>
<pre><code class='language-python' lang='python'>#!/usr/bin/python2
# -*- coding: utf-8 -*-
ANSIBALLZ_WRAPPER = True # For test-module script to tell this is a ANSIBALLZ_WRAPPER
# This code is part of Ansible, but is an independent component.
# The code in this particular templatable string, and this templatable string
# only, is BSD licensed.  Modules which end up using this snippet, which is
# dynamically combined together by Ansible still belong to the author of the
# module, and they may assign their own license to the complete work.
#
# Copyright (c), James Cammarata, 2016
# Copyright (c), Toshio Kuratomi, 2016
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
import os
import os.path
import sys
import __main__

# For some distros and python versions we pick up this script in the temporary
# directory.  This leads to problems when the ansible module masks a python
# library that another import needs.  We have not figured out what about the
# specific distros and python versions causes this to behave differently.
#
# Tested distros:
# Fedora23 with python3.4  Works
# Ubuntu15.10 with python2.7  Works
# Ubuntu15.10 with python3.4  Fails without this
# Ubuntu16.04.1 with python3.5  Fails without this
# To test on another platform:
# * use the copy module (since this shadows the stdlib copy module)
# * Turn off pipelining
# * Make sure that the destination file does not exist
# * ansible ubuntu16-test -m copy -a &#39;src=/etc/motd dest=/var/tmp/m&#39;
# This will traceback in shutil.  Looking at the complete traceback will show
# that shutil is importing copy which finds the ansible module instead of the
# stdlib module
scriptdir = None
try:
    scriptdir = os.path.dirname(os.path.realpath(__main__.__file__))
except (AttributeError, OSError):
    # Some platforms don&#39;t set __file__ when reading from stdin
    # OSX raises OSError if using abspath() in a directory we don&#39;t have
    # permission to read (realpath calls abspath)
    pass
if scriptdir is not None:
    sys.path = [p for p in sys.path if p != scriptdir]

import base64
import shutil
import zipfile
import tempfile
import subprocess

if sys.version_info &lt; (3,):
    bytes = str
    PY3 = False
else:
    unicode = str
    PY3 = True
try:
    # Python-2.6+
    from io import BytesIO as IOStream
except ImportError:
    # Python &lt; 2.6
    from StringIO import StringIO as IOStream

ZIPDATA = &quot;&quot;&quot;UEsDBBQAAAAIACJy/U6yxdenYQAAA...&quot;&quot;&quot;
# base64 编码内容，太长省略

def invoke_module(module, modlib_path, json_params):
    pythonpath = os.environ.get(&#39;PYTHONPATH&#39;)
    if pythonpath:
        os.environ[&#39;PYTHONPATH&#39;] = &#39;:&#39;.join((modlib_path, pythonpath))
    else:
        os.environ[&#39;PYTHONPATH&#39;] = modlib_path

    p = subprocess.Popen([&#39;/usr/bin/python2&#39;, module], env=os.environ, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
    (stdout, stderr) = p.communicate(json_params)

    if not isinstance(stderr, (bytes, unicode)):
        stderr = stderr.read()
    if not isinstance(stdout, (bytes, unicode)):
        stdout = stdout.read()
    if PY3:
        sys.stderr.buffer.write(stderr)
        sys.stdout.buffer.write(stdout)
    else:
        sys.stderr.write(stderr)
        sys.stdout.write(stdout)
    return p.returncode

def debug(command, zipped_mod, json_params):
    # The code here normally doesn&#39;t run.  It&#39;s only used for debugging on the
    # remote machine.
    #
    # The subcommands in this function make it easier to debug ansiballz
    # modules.  Here&#39;s the basic steps:
    #
    # Run ansible with the environment variable: ANSIBLE_KEEP_REMOTE_FILES=1 and -vvv
    # to save the module file remotely::
    #   $ ANSIBLE_KEEP_REMOTE_FILES=1 ansible host1 -m ping -a &#39;data=october&#39; -vvv
    #
    # Part of the verbose output will tell you where on the remote machine the
    # module was written to::
    #   [...]
    #   &lt;host1&gt; SSH: EXEC ssh -C -q -o ControlMaster=auto -o ControlPersist=60s -o KbdInteractiveAuthentication=no -o
    #   PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o
    #   ControlPath=/home/badger/.ansible/cp/ansible-ssh-%h-%p-%r -tt rhel7 &#39;/bin/sh -c &#39;&quot;&#39;&quot;&#39;LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
    #   LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping&#39;&quot;&#39;&quot;&#39;&#39;
    #   [...]
    #
    # Login to the remote machine and run the module file via from the previous
    # step with the explode subcommand to extract the module payload into
    # source files::
    #   $ ssh host1
    #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping explode
    #   Module expanded into:
    #   /home/badger/.ansible/tmp/ansible-tmp-1461173408.08-279692652635227/ansible
    #
    # You can now edit the source files to instrument the code or experiment with
    # different parameter values.  When you&#39;re ready to run the code you&#39;ve modified
    # (instead of the code from the actual zipped module), use the execute subcommand like this::
    #   $ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1461173013.93-9076457629738/ping execute

    # Okay to use __file__ here because we&#39;re running from a kept file
    basedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), &#39;debug_dir&#39;)
    args_path = os.path.join(basedir, &#39;args&#39;)
    script_path = os.path.join(basedir, &#39;ansible_module_setup.py&#39;)

    if command == &#39;explode&#39;:
        # transform the ZIPDATA into an exploded directory of code and then
        # print the path to the code.  This is an easy way for people to look
        # at the code on the remote machine for debugging it in that
        # environment
        z = zipfile.ZipFile(zipped_mod)
        for filename in z.namelist():
            if filename.startswith(&#39;/&#39;):
                raise Exception(&#39;Something wrong with this module zip file: should not contain absolute paths&#39;)

            dest_filename = os.path.join(basedir, filename)
            if dest_filename.endswith(os.path.sep) and not os.path.exists(dest_filename):
                os.makedirs(dest_filename)
            else:
                directory = os.path.dirname(dest_filename)
                if not os.path.exists(directory):
                    os.makedirs(directory)
                f = open(dest_filename, &#39;wb&#39;)
                f.write(z.read(filename))
                f.close()

        # write the args file
        f = open(args_path, &#39;wb&#39;)
        f.write(json_params)
        f.close()

        print(&#39;Module expanded into:&#39;)
        print(&#39;%s&#39; % basedir)
        exitcode = 0

    elif command == &#39;execute&#39;:
        # Execute the exploded code instead of executing the module from the
        # embedded ZIPDATA.  This allows people to easily run their modified
        # code on the remote machine to see how changes will affect it.
        # This differs slightly from default Ansible execution of Python modules
        # as it passes the arguments to the module via a file instead of stdin.

        # Set pythonpath to the debug dir
        pythonpath = os.environ.get(&#39;PYTHONPATH&#39;)
        if pythonpath:
            os.environ[&#39;PYTHONPATH&#39;] = &#39;:&#39;.join((basedir, pythonpath))
        else:
            os.environ[&#39;PYTHONPATH&#39;] = basedir

        p = subprocess.Popen([&#39;/usr/bin/python2&#39;, script_path, args_path],
                env=os.environ, shell=False, stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, stdin=subprocess.PIPE)
        (stdout, stderr) = p.communicate()

        if not isinstance(stderr, (bytes, unicode)):
            stderr = stderr.read()
        if not isinstance(stdout, (bytes, unicode)):
            stdout = stdout.read()
        if PY3:
            sys.stderr.buffer.write(stderr)
            sys.stdout.buffer.write(stdout)
        else:
            sys.stderr.write(stderr)
            sys.stdout.write(stdout)
        return p.returncode

    elif command == &#39;excommunicate&#39;:
        # This attempts to run the module in-process (by importing a main
        # function and then calling it).  It is not the way ansible generally
        # invokes the module so it won&#39;t work in every case.  It is here to
        # aid certain debuggers which work better when the code doesn&#39;t change
        # from one process to another but there may be problems that occur
        # when using this that are only artifacts of how we&#39;re invoking here,
        # not actual bugs (as they don&#39;t affect the real way that we invoke
        # ansible modules)

        # stub the args and python path
        sys.argv = [&#39;setup&#39;, args_path]
        sys.path.insert(0, basedir)

        from ansible_module_setup import main
        main()
        print(&#39;WARNING: Module returned to wrapper instead of exiting&#39;)
        sys.exit(1)
    else:
        print(&#39;WARNING: Unknown debug command.  Doing nothing.&#39;)
        exitcode = 0

    return exitcode

if __name__ == &#39;__main__&#39;:
    #
    # See comments in the debug() method for information on debugging
    #

    ANSIBALLZ_PARAMS = &#39;{&quot;ANSIBLE_MODULE_ARGS&quot;: {&quot;_ansible_version&quot;: &quot;2.6.5&quot;, &quot;_ansible_selinux_special_fs&quot;: [&quot;fuse&quot;, &quot;nfs&quot;, &quot;vboxsf&quot;, &quot;ramfs&quot;, &quot;9p&quot;], &quot;_ansible_no_log&quot;: false, &quot;_ansible_module_name&quot;: &quot;setup&quot;, &quot;_ansible_remote_tmp&quot;: &quot;~/.ansible/tmp&quot;, &quot;_ansible_verbosity&quot;: 3, &quot;_ansible_keep_remote_files&quot;: true, &quot;_ansible_syslog_facility&quot;: &quot;LOG_USER&quot;, &quot;_ansible_socket&quot;: null, &quot;_ansible_diff&quot;: false, &quot;_ansible_debug&quot;: false, &quot;_ansible_shell_executable&quot;: &quot;/bin/sh&quot;, &quot;_ansible_check_mode&quot;: false, &quot;_ansible_tmpdir&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1564381025.55-236313195829600/&quot;}}&#39;
    if PY3:
        ANSIBALLZ_PARAMS = ANSIBALLZ_PARAMS.encode(&#39;utf-8&#39;)
    try:
        # There&#39;s a race condition with the controller removing the
        # remote_tmpdir and this module executing under async.  So we cannot
        # store this in remote_tmpdir (use system tempdir instead)
        temp_path = tempfile.mkdtemp(prefix=&#39;ansible_&#39;)

        zipped_mod = os.path.join(temp_path, &#39;ansible_modlib.zip&#39;)
        modlib = open(zipped_mod, &#39;wb&#39;)
        modlib.write(base64.b64decode(ZIPDATA))
        modlib.close()

        if len(sys.argv) == 2:
            exitcode = debug(sys.argv[1], zipped_mod, ANSIBALLZ_PARAMS)
        else:
            z = zipfile.ZipFile(zipped_mod, mode=&#39;r&#39;)
            module = os.path.join(temp_path, &#39;ansible_module_setup.py&#39;)
            f = open(module, &#39;wb&#39;)
            f.write(z.read(&#39;ansible_module_setup.py&#39;))
            f.close()

            # When installed via setuptools (including python setup.py install),
            # ansible may be installed with an easy-install.pth file.  That file
            # may load the system-wide install of ansible rather than the one in
            # the module.  sitecustomize is the only way to override that setting.
            z = zipfile.ZipFile(zipped_mod, mode=&#39;a&#39;)

            # py3: zipped_mod will be text, py2: it&#39;s bytes.  Need bytes at the end
            sitecustomize = u&#39;import sys\nsys.path.insert(0,&quot;%s&quot;)\n&#39; %  zipped_mod
            sitecustomize = sitecustomize.encode(&#39;utf-8&#39;)
            # Use a ZipInfo to work around zipfile limitation on hosts with
            # clocks set to a pre-1980 year (for instance, Raspberry Pi)
            zinfo = zipfile.ZipInfo()
            zinfo.filename = &#39;sitecustomize.py&#39;
            zinfo.date_time = ( 2019, 7, 29, 6, 17, 5)
            z.writestr(zinfo, sitecustomize)
            z.close()

            exitcode = invoke_module(module, zipped_mod, ANSIBALLZ_PARAMS)
    finally:
        try:
            shutil.rmtree(temp_path)
        except (NameError, OSError):
            # tempdir creation probably failed
            pass
    sys.exit(exitcode)
</code></pre>
<p>&nbsp;</p>
</details>

从这里来看，大概能描述ansible的工作原理。ansible将模块依赖的内置ansible库打包成zip格式的压缩文件，并且使用base64进行编码，放在一个python脚本中，发送到远程节点上，执行完之后，将执行结果发送的执行ansible命令的master节点上，最后将结果经过处理之后打印到屏幕输出。

- 展开模块，查看目录结构

```bash
python setup.py explode
ls debug_dir
tree -d
```

![explode ansible module](/assets/images/explode-ansible-module.png)

可以看到，通过explode命令可以将ansible模块的内容提取到debug_dir目录，在debug_dir中，有一个目录，两个文件。

- ansible # 这个模块依赖的ansible library
- ansible_module_setup.py # 调用模块的脚本
- args # 运行模块的参数

我们可以在debug_dir中直接修改或执行脚本进行调试。

```bash
python ansible_module_setup.py args
```
